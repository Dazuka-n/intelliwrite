from typing import Optional

from .models import Blog


def get_blog_by_user_and_company(session, *, user_id: str, company_url: str) -> Optional[Blog]:
    return (
        session.query(Blog)
        .filter(Blog.user_id == user_id, Blog.company_url == company_url)
        .order_by(Blog.created_at.desc())
        .first()
    )


def create_blog_entry(
    session,
    *,
    user_id: str,
    topic: str,
    company_url: str,
    email_id: str = None,
    brand_name: str = None,
    blog: Optional[str] = None,
    status: str = "PENDING",
    twitter_post: Optional[str] = None,
    linkedin_post: Optional[str] = None,
    reddit_post: Optional[str] = None,
    is_prompt: str = "false",
    timestamp: str = None,
):
    entry = Blog(
        user_id=user_id,
        topic=[Blog.make_entry(topic, is_prompt=is_prompt, timestamp=timestamp)] if topic else [],
        company_url=company_url,
        email_id=email_id,
        brand_name=brand_name,
        blogs=[Blog.make_entry(blog, timestamp=timestamp)] if blog else [],
        status=status,
        twitter_post=[Blog.make_entry(twitter_post)] if twitter_post else [],
        linkedin_post=[Blog.make_entry(linkedin_post)] if linkedin_post else [],
        reddit_post=[Blog.make_entry(reddit_post)] if reddit_post else [],
    )
    session.add(entry)
    session.flush()  # populate autogenerated fields
    return entry


def get_blog_by_id(session, blog_id):
    return session.query(Blog).filter(Blog.id == blog_id).one_or_none()


def update_blog_status(session, blog_id, *, status, blog_content=None, topic: Optional[str] = None, is_prompt: str = "false", timestamp: str = None):
    blog = get_blog_by_id(session, blog_id)
    if not blog:
        raise ValueError(f"Blog with id {blog_id} not found")

    blog.status = status
    if blog_content is not None:
        blogs = Blog.ensure_entries(blog.blogs)
        entry = Blog.make_entry(blog_content, timestamp=timestamp, topic=topic, is_prompt=is_prompt)
        blogs.append(entry)
        blog.blogs = blogs

    if topic:
        topics = Blog.ensure_entries(blog.topic)
        contents = Blog.entry_contents(topics)
        if topic not in contents:
            topics.append(Blog.make_entry(topic, is_prompt=is_prompt, timestamp=timestamp))
            blog.topic = topics

    session.add(blog)
    session.flush()
    return blog


def append_social_post(session, blog: Blog, platform: str, content: str, topic: Optional[str] = None, timestamp: Optional[str] = None):
    platform = platform.lower()
    new_entry = Blog.make_entry(content, timestamp=timestamp, topic=topic)
    
    if platform == "twitter":
        current_list = Blog.ensure_entries(blog.twitter_post)
    elif platform == "linkedin":
        current_list = Blog.ensure_entries(blog.linkedin_post)
    elif platform == "reddit":
        current_list = Blog.ensure_entries(blog.reddit_post)
    else:
        raise ValueError(f"Unsupported platform for saving: {platform}")

    # Remove existing entries with the same topic to avoid duplicates
    if topic:
        normalized = []
        for entry in current_list:
            if not isinstance(entry, dict):
                entry = Blog.make_entry(entry)
            if entry and entry.get("topic") != topic:
                normalized.append(entry)
        current_list = normalized
    
    current_list.append(new_entry)

    if platform == "twitter":
        blog.twitter_post = current_list
    elif platform == "linkedin":
        blog.linkedin_post = current_list
    elif platform == "reddit":
        blog.reddit_post = current_list

    session.add(blog)
    session.flush()
    return blog
